import javax.security.auth.x500.X500Principal
import java.util.concurrent.TimeUnit

plugins {
    id 'java-library'
    id 'checkstyle'
    id 'groovy'
    id 'java'
}


configurations {
    combinedWorker{
        canBeConsumed = false
        canBeResolved= true
    }

    cordaCli{
        canBeConsumed = false
        canBeResolved= true
    }

    cordaCliMgmPlugin {
        canBeConsumed = false
        canBeResolved = true
    }

    cordaCliPackagePlugin {
        canBeConsumed = false
        canBeResolved = true
    }

    myCordaCpb {
        canBeConsumed = false
    }

    myPostgresJDBC {
        canBeConsumed = false
        canBeResolved = true
    }

    all {
        resolutionStrategy {
            // FORCE Gradle to use latest dynamic versions.
            cacheDynamicVersionsFor 0, 'seconds'
        }
    }

}

// Dependencies for supporting tools
dependencies {
    combinedWorker "net.corda:corda-combined-worker:$combinedWorkerVersion"
    cordaCli "net.corda.cli.host:corda-cli:$cordaCliVersion"
    cordaCliMgmPlugin "net.corda.cli.deployment:mgm-cli-plugin:$cordaCliPluginsVersion"
    cordaCliPackagePlugin "net.corda.cli.deployment:package-cli-plugin:$cordaCliPluginsVersion"
    myPostgresJDBC 'org.postgresql:postgresql:42.4.1'
}

def cordaBinDir="${System.getProperty('user.home')}/.corda/corda5"
def cordaCliDir = "$cordaBinDir/corda-cli"
def cordaJDBCDir = "$cordaBinDir/jdbcDrivers"
def CORDA_CLI_PLUGINS_DIR = "${cordaCliDir}/plugins"

tasks.register("getPostgresJDBC") {
    doLast {
        copy {
            from configurations.myPostgresJDBC
            into "$cordaJDBCDir"
        }
    }
}

tasks.register('listCli'){
    print("Corda-Cli configuration:")
    configurations.cordaCli.each { println(it) }
    print("MGM configuration:")
    configurations.cordaCliMgmPlugin.each { println(it) }
    print("Package configuration:")
    configurations.cordaCliPackagePlugin.each { println(it) }

}


tasks.register('projInit') {
    doLast {
        mkdir devEnvWorkspace
    }
}


tasks.register("getCordaCli") {
    //dependsOn('getCordaCliMgmPlugin', 'getCordaCliPackagePlugin')
    doLast {
        delete {
            delete cordaCliDir
        }
        copy {
            from configurations.cordaCli
            into "$cordaCliDir"
        }
        copy {
            from configurations.cordaCliPackagePlugin
            into "$cordaCliDir/plugins"
        }
        copy {
            from configurations.cordaCliMgmPlugin
            into "$cordaCliDir/plugins"
        }
    }
}

tasks.register("createGroupPolicy") {
    dependsOn('projInit', 'getCordaCli')
    doLast {
        println("Creating a GroupPolicy")
        javaexec {
            classpath = configurations.cordaCli
            jvmArgs = ["-Dpf4j.pluginsDir=$CORDA_CLI_PLUGINS_DIR"]
            standardOutput = new FileOutputStream("${devEnvWorkspace}/GroupPolicy.json")
            LinkedList<String> myArgs = new LinkedList<String>()
            myArgs.add("mgm")
            myArgs.add("groupPolicy")
            def jsonFile = file("$rootDir/config/dev-net.json")
            def slurper = new groovy.json.JsonSlurper()
            def parsedJson = slurper.parseText(jsonFile.text)
            parsedJson.identities.forEach {
                myArgs.add("--name")
                myArgs.add(it)
            }

            myArgs.add("--endpoint-protocol=1")
            myArgs.add("--endpoint=http://localhost:1080")
            args myArgs
        }

    }
}

/*
tasks.register("createGroupPolicy") {
    dependsOn('projInit', 'getCordaCli')
    doLast {
        println("Creating a GroupPolicy")
        println("cordaCli jar: ${configurations.cordaCli.singleFile.toString()}")
        String groupPolicyFName = new String("${devEnvWorkspace}/GroupPolicy.json".toString())
        def groupPolicyFile = new File(groupPolicyFName)
        println("GroupPolicy file: $groupPolicyFile")

        def cordaCliJar = configurations.cordaCli.singleFile
        def javaBinDir = "${System.getProperty("java.home")}/bin"
        def jsonFile = file("$rootDir/config/dev-net.json")
        def slurper = new groovy.json.JsonSlurper()
        def parsedJson = slurper.parseText(jsonFile.text)

        LinkedList<String> cmdArgs = new LinkedList<String>()
        cmdArgs.add("${javaBinDir}/java".toString())
        cmdArgs.add("-Dpf4j.pluginsDir=$CORDA_CLI_PLUGINS_DIR".toString())
        cmdArgs.add("-jar")
        //cmdArgs.add("${configurations.cordaCli.singleFile.toString()}")
        cmdArgs.add("${cordaCliJar}".toString())
        cmdArgs.add("mgm")
        cmdArgs.add("groupPolicy")

        parsedJson.identities.forEach {
            cmdArgs.add("--name")
            cmdArgs.add(it)
        }
        cmdArgs.add("--endpoint-protocol=1")
        cmdArgs.add("--endpoint=http://localhost:1080")
        println("CmdArgs=${cmdArgs}")
        def pb = new ProcessBuilder(cmdArgs)
        // pb.redirectErrorStream(true)
        pb.redirectOutput(ProcessBuilder.Redirect.to(groupPolicyFile))

        def proc = pb.start()
        //proc.waitFor(60, TimeUnit.SECONDS)
        assert pb.redirectOutput().file() == groupPolicyFile
        proc.waitFor()


    }
}

tasks.register("createGroupPolicy") {
    dependsOn('projInit', 'getCordaCli')
    doLast {
        println("FAKE CREATE GroupPolicy - use pregen")
    }
}
*/


tasks.register("getDevCordaLite", Copy) {
    from configurations.combinedWorker
    into cordaBinDir
}

/*
tasks.register('addTsaCertToKeystore') {
    dependsOn ('createKeystore')
    doLast {
        println('addTsaCertToKeystore running')
        exec {
            commandLine "keytool", "-importcert",
                    "-alias", "freetsa",
                    "-keystore", "signingkeys.pfx",
                    "-storepass", "keystore password",
                    "-file", "cacert.pem",
                    "-noprompt"
        }
    }

}

tasks.register('deleteOldSigningKeys'){
        doLast {
            println('deleteOldSigningKeys running')
            delete {
               "${rootDir}/signingkeys.pfx"
            }
            exec {
                commandLine 'ls', '-l', rootDir
            }
        }
}


 */

tasks.register('createKeystore') {
    println('createKeystore')
    println("devEnvWorkspace=$devEnvWorkspace")
    doLast {
        delete {
            delete "$devEnvWorkspace/signingkeys.pfx"
        }
        exec {
            commandLine "keytool", "-genkey",
                    "-alias", "my-signing-key",
                    "-keystore", "$devEnvWorkspace/signingkeys.pfx",
                    "-storepass", "keystore password",
                    "-dname", "cn=CPI Example - My Signing Key, o=CorpOrgCorp, c=GB",
                    "-keyalg", "RSA",
                    "-storetype", "pkcs12",
                    "-validity", "4000"
        }
        // Need to add the default signing key to the keystore
        exec {
            commandLine "keytool", "-importcert",
            "-keystore", "$devEnvWorkspace/signingkeys.pfx",
            "-storepass", "keystore password",
            "-noprompt",
            "-alias", "gradle-plugin-default-key",
            "-file", "$rootDir/config/gradle-plugin-default-key.pem"
        }

    }
}


tasks.register('buildCPI') {
    dependsOn('build', 'createGroupPolicy', 'createKeystore')
    // dependsOn('build', 'createKeystore')

    doLast{
        def cpiFile= "${buildDir}/${project.archivesBaseName}-${project.version}.cpi"
        delete { delete cpiFile }
        File srcDir
        srcDir = file('build/libs')

        // Create a file collection using a closure
        def collection = layout.files { srcDir.listFiles() }
        //def cpbs = collection.filter { it.getName().endsWith(".cpb") }.each { println it }
        def cpbs = collection.filter { it.getName().endsWith(".cpb") }
        javaexec {
            classpath = configurations.cordaCli
            jvmArgs = ["-Dpf4j.pluginsDir=$CORDA_CLI_PLUGINS_DIR"]
            /*
            args 'package', 'create',
                    '--cpb', cpbs.singleFile.absolutePath,
                    '--group-policy', "${devEnvWorkspace}/GroupPolicy.json",
                    '--keystore', "${devEnvWorkspace}/signingkeys.pfx",
                    '--storepass', 'keystore password',
                    '--key', 'my-signing-key',
                    '--file', cpiFile
             */
            args 'package', 'create-cpi',
                    '--cpb', cpbs.singleFile.absolutePath,
                    '--group-policy', "${devEnvWorkspace}/GroupPolicy.json",
                    '--cpi-name', 'cpi name',
                    '--cpi-version', '1.0.0.0-SNAPSHOT',
                    '--file', cpiFile,
                    '--keystore', "${devEnvWorkspace}/signingkeys.pfx",
                    '--storepass', 'keystore password',
                    '--key', 'my-signing-key'
        }
    }
}

tasks.register("deployCPI") {
    dependsOn('buildCPI')
    doLast {
        def retryLimit = 10
        def retryWaitInMs = 3000
        def retries=0
        def cpi = "${buildDir}/${project.archivesBaseName}-${project.version}.cpi"
        exec {
            standardOutput = new FileOutputStream("${devEnvWorkspace}/CPIupload.json")
            commandLine "curl", "--insecure", "-u", "admin:admin", "-s",
                    "-F", "upload=@$cpi",
                    "${cordaClusterURL}/api/v1/cpi/"
        }
        def jsonFile = file("${devEnvWorkspace}/CPIupload.json")
        // println("upload attempt output:${jsonFile.text}")
        def slurper = new groovy.json.JsonSlurper()
        def parsedJson = slurper.parseText(jsonFile.text)
        // println("Request ID=${parsedJson.id}")


        // Loop if status != 400 and we don't have have a CPI Checksum
        def requestId = parsedJson.id
        // println(requestId)
        Object parsedJsonCPI = null
        do {
            Thread::sleep(retryWaitInMs)
            exec {
                standardOutput = new FileOutputStream("${devEnvWorkspace}/CPIFileStatus.json")
                commandLine "curl", "--insecure", "-u", "admin:admin", "-s",
                        "${cordaClusterURL}/api/v1/cpi/status/${requestId}"
            }
            def jsonFileCPI = file("${devEnvWorkspace}/CPIFileStatus.json")
            println("initial upload status:${jsonFileCPI.text}")
            parsedJsonCPI = new groovy.json.JsonSlurper().parseText(jsonFileCPI.text)
            // println("status=$parsedJsonCPI.status")
        } while(parsedJsonCPI != null && parsedJsonCPI.status instanceof String && parsedJsonCPI.status != "OK")
        println("upload CPI reponse JSON=$parsedJsonCPI")
        if (!parsedJsonCPI.status.equals("OK")) {
            // println("CPI Deployment failed:$parsedJsonCPI.details.errorMessage")

            // Attempt forceCPIupload
            exec {
                standardOutput = new FileOutputStream("${devEnvWorkspace}/CPIupload.json")
                commandLine "curl", "--insecure", "-u", "admin:admin", "-s",
                        "-F", "upload=@$cpi",
                        "${cordaClusterURL}/api/v1/maintenance/virtualnode/forcecpiupload/"
            }
            def jsonFileForce = file("${devEnvWorkspace}/CPIupload.json")
            def slurperForce = new groovy.json.JsonSlurper()
            // println("forcecpiload output=${jsonFileForce.text}")
            def parsedJsonForce = slurper.parseText(jsonFileForce.text)
            // println("Request ID=${parsedJsonForce.id}")


            // Loop if status != 400 and we don't have have a CPI Checksum
            def jsonFileA = file("${devEnvWorkspace}/CPIupload.json")
            requestId = (new groovy.json.JsonSlurper().parseText(jsonFileA.text)).id
            // println(requestId)

            def jsonFileForceStatus = null
            do {

                Thread::sleep(3000)
                exec {
                    standardOutput = new FileOutputStream("${devEnvWorkspace}/CPIFileStatus.json")
                    commandLine "curl", "--insecure", "-u", "admin:admin", "-s",
                            "${cordaClusterURL}/api/v1/cpi/status/${requestId}"
                }
                jsonFileForceStatus = file("${devEnvWorkspace}/CPIFileStatus.json")
                parsedJson = new groovy.json.JsonSlurper().parseText(jsonFileForceStatus.text)

                //  println("status=$parsedJson.status")
            } while (parsedJson != null && parsedJson.status instanceof String && parsedJson.status != "OK")

            if (!parsedJson.status.equals("OK")) {
                println("CPI Deployment failed:$parsedJson.details.errorMessage")
                println(jsonFileForceStatus.text)
                throw new GradleException("CPI Deployment failed.\n$parsedJson.details.errorMessage")
            } else {
                //println("CPI checksum=${parsedJson.cpiFileChecksum}")
            }

        } else {
            //println("CPI checksum=${parsedJsonCPI.cpiFileChecksum}")
        }
    }
}


tasks.register("uploadCPI") {
    dependsOn('projInit')
    doLast {
        def cpi = "${buildDir}/${project.archivesBaseName}-${project.version}.cpi"
        println("cpi=$cpi")
        exec {
            standardOutput = new FileOutputStream("${devEnvWorkspace}/CPIupload.json")
            commandLine "curl", "--insecure", "-u", "admin:admin", "-s",
                    "-F", "upload=@$cpi",
                    "${cordaClusterURL}/api/v1/cpi/"
        }
        def jsonFile = file("${devEnvWorkspace}/CPIupload.json")
        def slurper = new groovy.json.JsonSlurper()
        def parsedJson = slurper.parseText(jsonFile.text)
        println("Request ID=${parsedJson.id}")
    }
}

tasks.register("forceUploadCPI") {
    dependsOn('projInit')
    doLast {
        def cpi = "${buildDir}/${project.archivesBaseName}-${project.version}.cpi"
        standardOutput = new FileOutputStream("${devEnvWorkspace}/CPIupload.json")
        exec {
            commandLine "curl", "--insecure", "-u", "admin:admin",  "-s",
                    "-F", "upload=@$cpi",
                    "${cordaClusterURL}/api/v1/maintenance/virtualnode/forcecpiupload/"
        }
        def jsonFile = file("${devEnvWorkspace}/CPIupload.json")
        def parsedJson = new groovy.json.JsonSlurper().parseText(jsonFile.text)
        println("${parsedJson.id}")
    }
}



tasks.register("uploadCPIStatus") {
    // dependsOn ('uploadCPI')
    dependsOn('projInit')
    doLast {
        def jsonFileA = file("${devEnvWorkspace}/CPIupload.json")
        def requestId = (new groovy.json.JsonSlurper().parseText(jsonFileA.text)).id
        // println(requestId)
        exec {
            standardOutput = new FileOutputStream("${devEnvWorkspace}/CPIFileStatus.json")
            commandLine "curl", "--insecure", "-u", "admin:admin",  "-s",
                    "${cordaClusterURL}/api/v1/cpi/status/${requestId}"
        }
        def jsonFile = file("${devEnvWorkspace}/CPIFileStatus.json")
        def parsedJson = new groovy.json.JsonSlurper().parseText(jsonFile.text)

        // println("status=$parsedJson.status")
        if (!parsedJson.status.equals("OK")) {
            println("CPI Deployment failed:$parsedJson.details.errorMessage")
            println(parsedJson)
            throw new GradleException("CPI Deployment failed.\n$parsedJson.details.errorMessage")
        } else {
            println("CPI checksum=${parsedJson.cpiFileChecksum}")
        }
    }
}

class VNodeInfo {
    public VNodeInfo(String shash, String cpi) {
        ShortHash=shash;
        CPIName=cpi;
    }
    public String ShortHash;
    public String CPIName;
}

tasks.register("createVNodes") {
    dependsOn('deployCPI')
    doLast {
        def jsonFile = file("$rootDir/config/dev-net.json")
        def slurper = new groovy.json.JsonSlurper()
        def parsedJson = slurper.parseText(jsonFile.text)
        def CpiFileStatusFile = file("${devEnvWorkspace}/CPIFileStatus.json")
        def cpiChkSum = (new groovy.json.JsonSlurper().parseText(CpiFileStatusFile.text)).cpiFileChecksum
        // println("ParsedJson=${parsedJson.identities}")
        def namesToShortHashes = new HashMap<String,String>()
        HashMap<String, VNodeInfo> namesToVNodeInfo = new HashMap<String, VNodeInfo>()

        delete {
            delete "${devEnvWorkspace}/vnodes.json"
        }
        exec {
            standardOutput = new FileOutputStream("${devEnvWorkspace}/existingvnodes.json")
            commandLine "curl", "--insecure", "-u", "admin:admin", "-s",
                    "${cordaClusterURL}/api/v1/virtualnode"
        }

        def existingVNodes = new HashSet<X500Principal>()
        def rawExistingVNodeData=file("${devEnvWorkspace}/existingvnodes.json")
        def existingVNodeData = new groovy.json.JsonSlurper().parseText(rawExistingVNodeData.text)
        /*
        existingVNodeData.virtualNodes.forEach {
            println("Existing: ${it.holdingIdentity.x500Name}")
        }

         */
        existingVNodeData.virtualNodes.forEach {
            existingVNodes.add(new X500Principal(it.holdingIdentity.x500Name))
        }

        /*
        println("Existing as X500Principals:")
        existingVNodes.forEach {
            println("X500Principal: $it")
        }

        // Doesn't not work
        println("Check for existence with string search:")
        existingVNodeData.virtualNodes.forEach {
            String myX500Name = it.holdingIdentity.x500Name
            println("$myX500Name: does it match ${existingVNodes.contains(myX500Name)}")
        }

        // Need to create X500... thing to work
        println("Check for existence with X500Principal search:")
        existingVNodeData.virtualNodes.forEach {
            String myX500Name = it.holdingIdentity.x500Name
            println("${myX500Name}: does it match ${existingVNodes.contains(new X500Principal(myX500Name))}")
        }
        parsedJson.identities.forEach {
            X500Principal x500 = new X500Principal(it)
            println("$it, as X500 getname ${x500.getName()}, as string ${x500}")
        }
        */

        Thread::sleep(6000)
        def vnodeInfoOutput = new PrintStream(new FileOutputStream("${devEnvWorkspace}/vnodeinfo.csv"))
        parsedJson.identities.forEach {
            def X500 = it
            if (!existingVNodes.contains(new X500Principal(X500))) {
                //println("Create VNode for $X500 with CPI(with check sum) $cpiChkSum")
                exec {
                    standardOutput = new FileOutputStream("${devEnvWorkspace}/vnodetemp.json")
                    commandLine "curl", "--insecure", "-u", "admin:admin", "-s",
                            "-d", "{ \"request\" : { \"cpiFileChecksum\": \"$cpiChkSum\", \"x500Name\": \"$X500\"  } }",
                            "${cordaClusterURL}/api/v1/virtualnode"
                }
                def outputData = file("${devEnvWorkspace}/vnodetemp.json")
                println("Data=${outputData.text}")
                // TODO: Can do error checking with this
                def jsonOut = new groovy.json.JsonSlurper().parseText(outputData.text)

                if(jsonOut.holdingIdentity != null) {
                    def idShortHash = jsonOut.holdingIdentity.shortHash
                    namesToShortHashes.put(X500, idShortHash)
                    namesToVNodeInfo.put(X500, new VNodeInfo(idShortHash, cpiChkSum))
                    //println("\"$X500\", \"$idShortHash\"")
                    //println(".shortHash=$idShortHash")
                }

            } else {
                //println("Already created $X500")
            }
        }

        // Debugging

        exec {
            commandLine "curl", "--insecure", "-u", "admin:admin", "-s",
                    "${cordaClusterURL}/api/v1/virtualnode"
        }

        /*
        def vnodeInfoOutput = new PrintStream(new FileOutputStream("${devEnvWorkspace}/vnodeinfo.json"))
        //createVNodeFile(vnodeInfoOutput, namesToVNodeInfo)
        vnodeInfoOutput.println('{')
        vnodeInfoOutput.println("  \"vnodes\": [")
        boolean first=true
        for(String X500: namesToVNodeInfo) {
            VNodeInfo info = namesToVNodeInfo.get(X500)
            vnodeInfoOutput.print("    { \"X500\": \"" + X500 + "\", \"shortHash\": \"" + info.ShortHash + "\", \"CPI\": \"" + info.CPIName +"\" }" )
            if(!first) { print(',')}
            vnodeInfoOutput.print('\n')
        }
        vnodeInfoOutput.println('  ]\n}')
        */

        /*
        // Code the check for registration
        parsedJson.identities.forEach {
            def X500 = it
            if (!existingVNodes.contains(new X500Principal(X500))) {
                if(namesToShortHashes.get(X500)!= null) {
                    println("Register $X500 with shorthash ${namesToShortHashes.get(X500)}")
                    exec {
                        commandLine "curl", "--insecure", "-u", "admin:admin", "-s",
                                "-d", '{ "memberRegistrationRequest": { "action": "requestJoin",  "context": { "corda.key.scheme" : "CORDA.ECDSA.SECP256R1" } } }',
                                "${cordaClusterURL}/api/v1/membership/${namesToShortHashes.get(X500)}"
                    }
                    print('\n')
                }
            }
        }

         */
    }
}

tasks.register('regAllVNodes') {
    // Code the check for registration
    dependsOn('createVNodes')
    doLast {
        exec {
            standardOutput = new FileOutputStream("${devEnvWorkspace}/existingvnodes.json")
            commandLine "curl", "--insecure", "-u", "admin:admin", "-s",
                    "${cordaClusterURL}/api/v1/virtualnode"
        }

        def existingVNodes = new HashSet<X500Principal>()
        def rawExistingVNodeData = file("${devEnvWorkspace}/existingvnodes.json")
        def existingVNodeData = new groovy.json.JsonSlurper().parseText(rawExistingVNodeData.text)

        existingVNodeData.virtualNodes.forEach {
            def X500 = it.holdingIdentity.x500Name
            def shortHash = it.holdingIdentity.shortHash
            println("Register $X500 with shorthash ${shortHash}")
            exec {
                commandLine "curl", "--insecure", "-u", "admin:admin", "-s",
                        "-d", '{ "memberRegistrationRequest": { "action": "requestJoin",  "context": { "corda.key.scheme" : "CORDA.ECDSA.SECP256R1" } } }',
                        "${cordaClusterURL}/api/v1/membership/${shortHash}"
            }
            print('\n')
        }
    }
}

tasks.register('listVNodes') {
    doLast {
        exec {
            standardOutput = new FileOutputStream("${devEnvWorkspace}/tempy.json")
            commandLine "curl", "--insecure", "-u", "admin:admin", "-s",
                    "${cordaClusterURL}/api/v1/virtualnode"
        }

        def existingVNodes = new HashSet<X500Principal>()
        def rawExistingVNodeData = file("${devEnvWorkspace}/tempy.json")
        def existingVNodeData = new groovy.json.JsonSlurper().parseText(rawExistingVNodeData.text)
        existingVNodeData.virtualNodes.forEach {
            println("${it.holdingIdentity.x500Name}\t${it.holdingIdentity.shortHash}")
        }
    }
}


tasks.register('deployCordapp') {
    dependsOn("regAllVNodes")
}

def createVNodeFile(PrintWriter printer, HashMap<String,VNodeInfo> vnodeData) {
    printer.println('{')
    printer.println("  \"vnodes\": [")
    boolean first=true
    for(String X500: vnodeData) {
        VNodeInfo info = vnodeData.get(X500)
        printer.print("    { \"X500\": \"" + X500 + "\", \"shortHash\": \"" + info.ShortHash + "\", \"CPI\": \"" + info.CPIName +"\" }" )
        if(!first) { print(',')}
        printer.print('\n')
    }
    printer.println('  ]\n}')
}


tasks.register("startDB") {
    doLast {
        new ProcessBuilder(
                "docker",
                "run", "-d", "--rm",
                "-p", "5432:5432",
                "--name", dbContainerName,
                "-e", "POSTGRES_DB=cordacluster",
                "-e", "POSTGRES_USER=postgres",
                "-e", "POSTGRES_PASSWORD=password",
                "postgres:latest").start()
    }
}

tasks.register("startCordaLite") {
    dependsOn('getDevCordaLite', 'getPostgresJDBC')
    doLast {

        mkdir devEnvWorkspace

        def combiWorkerJar = configurations.combinedWorker.singleFile

        new ProcessBuilder(
                "docker",
                "run", "-d", "--rm",
                "-p", "5432:5432",
                "--name", dbContainerName,
                "-e", "POSTGRES_DB=cordacluster",
                "-e", "POSTGRES_USER=postgres",
                "-e", "POSTGRES_PASSWORD=password",
                "postgres:latest").start()
        Thread::sleep(10000)

        def javaBinDir = "${System.getProperty("java.home")}/bin"
        def procBuild = new ProcessBuilder("${javaBinDir}/java",
                "-agentlib:jdwp=transport=dt_socket,server=y,suspend=n,address=*:5005",
                "-Dco.paralleluniverse.fibers.verifyInstrumentation=true",
                "-jar",
                "$combiWorkerJar",
                "--instanceId=0",
                "-mbus.busType=DATABASE",
                "-spassphrase=password",
                "-ssalt=salt",
                "-spassphrase=password",
                "-ssalt=salt",
                "-ddatabase.user=user",
                "-ddatabase.pass=password",
                "-ddatabase.jdbc.url=jdbc:postgresql://localhost:5432/cordacluster",
                "-ddatabase.jdbc.directory=$cordaJDBCDir")


        procBuild.redirectErrorStream(true)
        Process proc = procBuild.start()

        def pidStore = new PrintStream(new FileOutputStream("$devEnvWorkspace/CordaPID.dat"))
        pidStore.print(proc.pid())
        println("Corda Process-id=$proc.pid")
    }
}

tasks.register("stopCordaLite") {
    doLast {
        def sc = new Scanner(new File("$devEnvWorkspace/CordaPID.dat"))
        def pid = sc.nextLong()
        println("pid to kill=$pid")

        /*
        def pHandle = ProcessHandle.of(pid)
        if(pHandle == null) { println("pHandle == null")}
        else { println("pHandle != null")}

        if(pHandle.ifPresent()) {
            pHandle.get().descendants().each { d ->
                d.destroy()
            }
            def pph = pHandle.get()
            pph.destroy()
        }

         */

        exec {
            commandLine "kill", "-9", pid
        }

        //new ProcessBuilder("$rootDir/tools/postgres-nonpersist-stop.sh").start()
        new ProcessBuilder("docker", "stop", dbContainerName).start()

        // def pHandle = ProcessHandle.of(pid)
        // pHandle.ifPresent(java.lang.ProcessHandle::destroy())
    }
}



task urldemo {
    doLast {
        Authenticator.setDefault (new Authenticator() {
            protected PasswordAuthentication getPasswordAuthentication() {
                return new PasswordAuthentication ("admin", "admin".toCharArray());
            }
        })
        def body = [user: "dummyUser"]
        def req = new URL("${cordaClusterURL}/").openConnection()

        req.setRequestMethod("POST")
        req.setRequestProperty("Content-Type", "application/json; charset=UTF-8")
        req.setDoOutput(true)
        req.getOutputStream().write(JsonOutput.toJson(body).getBytes("UTF-8"))
        logger.quiet "Status code: ${req.getResponseCode()}" // HTTP request done on first read
        def resp = new groovy.json.JsonSlurper().parseText(req.getInputStream().getText())
        logger.quiet "Response: ${resp}"
        println("Response: ${resp}")
    }
}


