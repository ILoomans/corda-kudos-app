import javax.security.auth.x500.X500Principal
import net.corda.v5.base.types.MemberX500Name

import kong.unirest.Unirest
import kong.unirest.json.JSONObject
import org.jetbrains.annotations.NotNull

import static java.lang.Thread.sleep

plugins {
    id 'java-library'
    id 'checkstyle'
    id 'groovy'
    id 'java'
}


configurations {
    combinedWorker{
        canBeConsumed = false
        canBeResolved= true
    }

    myPostgresJDBC {
        canBeConsumed = false
        canBeResolved = true
    }

}

// Dependencies for supporting tools
dependencies {
    combinedWorker "net.corda:corda-combined-worker:$combinedWorkerVersion"
    myPostgresJDBC 'org.postgresql:postgresql:42.4.1'
}


def pluginGroupName = "CSDE"
def pluginImplGroupName = "other"
def cordaBinDir= "${System.getProperty('user.home')}/.corda/corda5"
def cordaCliZipDir = "$cordaBinDir/cordaCliZip"
def cordaCliBinDir = "${System.getProperty('user.home')}/.corda/cli"
def cordaCliDir = "$cordaBinDir/corda-cli"
def cordaJDBCDir = "$cordaBinDir/jdbcDrivers"
def CORDA_CLI_PLUGINS_DIR = "${cordaCliDir}/plugins"
def signingCertAlias="gradle-plugin-default-key"
def signingCertFName = "$rootDir/config/gradle-plugin-default-key.pem"
def keystoreAlias = "my-signing-key"
def keystoreFName = "$devEnvWorkspace/signingkeys.pfx"
def keystoreCertFName = "$devEnvWorkspace/signingkey1.pem"

// Need to read things from cordapp plugin
def cpiName =  'cpi name'

tasks.register("getPostgresJDBC") {
    group = pluginImplGroupName
    doLast {
        copy {
            from configurations.myPostgresJDBC
            into "$cordaJDBCDir"
        }
    }
}

tasks.register('projInit') {
    group = pluginImplGroupName
    doLast {
         mkdir devEnvWorkspace
    }
}

tasks.register("createGroupPolicy") {
    group = pluginImplGroupName
    dependsOn('projInit')
    doLast {
            def csdeIface = new CsdeRpcInterface()

            def groupPolicyFName = new String("${devEnvWorkspace}/GroupPolicy.json")
            def devnetFName = new String("$rootDir/config/dev-net.json")
            File groupPolicyFile = new File(groupPolicyFName)
            File devnetFile = new File(devnetFName)
            if (!groupPolicyFile.exists() || groupPolicyFile.lastModified() < devnetFile.lastModified()) {
                def configX500Ids = csdeIface.getConfigX500Ids()

                println("Creating a GroupPolicy")

                LinkedList<String> cmdArgs = new LinkedList<String>()
                if (System.properties['os.name'].toLowerCase().contains('windows')) {
                    cmdArgs.add("$cordaCliBinDir/corda-cli.cmd")
                } else {
                    cmdArgs.add("$cordaCliBinDir/corda-cli.sh")
                }
                cmdArgs.add("mgm")
                cmdArgs.add("groupPolicy")
                configX500Ids.forEach {
                    cmdArgs.add("--name")
                    cmdArgs.add("$it")
                }

                cmdArgs.add("--endpoint-protocol=1")
                cmdArgs.add("--endpoint=http://localhost:1080")

                println("cmdArgs=$cmdArgs")
                exec {
                    standardOutput = new FileOutputStream(groupPolicyFName)
                    commandLine cmdArgs
                }
            } else {
                println("createPolicyTask: everything up to date; nothing to do")
            }

    }
}

tasks.register("getDevCordaLite", Copy) {
    group = pluginImplGroupName
    from configurations.combinedWorker
    into cordaBinDir
}

tasks.register('createKeystore') {
    group = pluginImplGroupName
    doLast {
        File keystoreFile = new File(keystoreFName)
        if(!keystoreFile.exists()) {
            println('createKeystore - creating keystore')
            exec {
                commandLine "keytool", "-genkeypair",
                        "-alias", keystoreAlias,
                        "-keystore", keystoreFName,
                        "-storepass", "keystore password",
                        "-dname", "CN=CPI Example - My Signing Key, O=CorpOrgCorp, L=London, C=GB",
                        "-keyalg", "RSA",
                        "-storetype", "pkcs12",
                        "-validity", "4000"
            }
            // Need to add the default signing key to the keystore
            exec {
                commandLine "keytool", "-importcert",
                        "-keystore", keystoreFName,
                        "-storepass", "keystore password",
                        "-noprompt",
                        "-alias", signingCertAlias,
                        "-file", signingCertFName
            }
            // keytool -exportcert -rfc -alias "signing key 1" -keystore signingkeys.pfx -storepass "keystore password" -file signingkey1.pem
            exec {
                commandLine "keytool",
                        "-exportcert", "-rfc", "-alias", keystoreAlias,
                        "-keystore", keystoreFName,
                        "-storepass", "keystore password",
                        "-file", keystoreCertFName
            }
            def iface = createCsdeRpcInterface()

        }
        else {
            println('createKeystore - keystore already created; nothing to do.')
        }

    }
}


tasks.register('buildCPI') {
    group = pluginGroupName
    dependsOn('build', 'createGroupPolicy', 'createKeystore')
    // dependsOn('build')

    doLast{
        def cpiFile= "${buildDir}/${project.archivesBaseName}-${project.version}.cpi"
        delete { delete cpiFile }
        File srcDir
        srcDir = file('build/libs')

        // Create a file collection using a closure
        def collection = layout.files { srcDir.listFiles() }
        def cpbs = collection.filter { it.getName().endsWith(".cpb") }

        LinkedList<String> cmdArgs = new LinkedList<String>()
        if (System.properties['os.name'].toLowerCase().contains('windows')) {
            cmdArgs.add("$cordaCliBinDir/corda-cli.cmd")
        }
        else {
            cmdArgs.add("$cordaCliBinDir/corda-cli.sh")
        }
        cmdArgs.add( 'package')
        cmdArgs.add('create-cpi')
        cmdArgs.add('--cpb')
        cmdArgs.add(cpbs.singleFile.absolutePath)
        cmdArgs.add('--group-policy')
        cmdArgs.add("${devEnvWorkspace}/GroupPolicy.json")
        cmdArgs.add('--cpi-name')
        cmdArgs.add(cpiName)
        cmdArgs.add('--cpi-version')
        cmdArgs.add(project.version)
        cmdArgs.add('--file')
        cmdArgs.add(cpiFile)
        cmdArgs.add('--keystore')
        cmdArgs.add("${devEnvWorkspace}/signingkeys.pfx")
        cmdArgs.add('--storepass')
        cmdArgs.add('keystore password')
        cmdArgs.add('--key')
        cmdArgs.add('my-signing-key')

        exec {
            commandLine cmdArgs
        }

    }
}

tasks.register("deployCPI") {
    group = pluginImplGroupName
    dependsOn('buildCPI')
    doLast {
        def corda = createCsdeRpcInterface()
        corda.uploadCertificate(signingCertAlias, signingCertFName)
        corda.uploadCertificate(keystoreAlias, keystoreCertFName)
        corda.deployCPI("${buildDir}/${project.archivesBaseName}-${project.version}.cpi", cpiName, project.version)
    }
}

tasks.register("createAndRegVNodes") {
    group = pluginImplGroupName
    dependsOn('deployCPI')
    doLast {
        def corda = createCsdeRpcInterface()
        corda.createAndRegVNodes()
    }
}


tasks.register('listVNodes') {
    group = pluginImplGroupName
    doLast {
        def corda = createCsdeRpcInterface()
        corda.listVNodes()
    }

}

tasks.register('listCPIs') {
    group = pluginImplGroupName
    doLast {
        def csdeIface = new CsdeRpcInterface()
        csdeIface.listCPIs()
    }
}


// Empty task, just acts as the Task user entry point task.
tasks.register('deployCordapp') {
    group = pluginGroupName
    dependsOn("createAndRegVNodes")
}


tasks.register("startCordaLite") {
    group = pluginGroupName
    dependsOn('getDevCordaLite', 'getPostgresJDBC')
    doLast {

        mkdir devEnvWorkspace

        def combiWorkerJar = configurations.combinedWorker.singleFile

        new ProcessBuilder(
                "docker",
                "run", "-d", "--rm",
                "-p", "5432:5432",
                "--name", dbContainerName,
                "-e", "POSTGRES_DB=cordacluster",
                "-e", "POSTGRES_USER=postgres",
                "-e", "POSTGRES_PASSWORD=password",
                "postgres:latest").start()
        Thread::sleep(10000)

        def javaBinDir = "${System.getProperty("java.home")}/bin"
        def procBuild = new ProcessBuilder("${javaBinDir}/java",
                "-agentlib:jdwp=transport=dt_socket,server=y,suspend=n,address=*:5005",
                "-Dco.paralleluniverse.fibers.verifyInstrumentation=true",
                "-jar",
                "$combiWorkerJar",
                "--instanceId=0",
                "-mbus.busType=DATABASE",
                "-spassphrase=password",
                "-ssalt=salt",
                "-spassphrase=password",
                "-ssalt=salt",
                "-ddatabase.user=user",
                "-ddatabase.pass=password",
                "-ddatabase.jdbc.url=jdbc:postgresql://localhost:5432/cordacluster",
                "-ddatabase.jdbc.directory=$cordaJDBCDir")


        procBuild.redirectErrorStream(true)
        Process proc = procBuild.start()

        def pidStore = new PrintStream(new FileOutputStream("$devEnvWorkspace/CordaPID.dat"))
        pidStore.print(proc.pid())
        println("Corda Process-id=${proc.pid()}")
    }
}

tasks.register("stopCordaLite") {
    group = pluginGroupName
    doLast {
        def sc = new Scanner(new File("$devEnvWorkspace/CordaPID.dat"))
        def pid = sc.nextLong()
        println("pid to kill=$pid")

        if (System.properties['os.name'].toLowerCase().contains('windows')) {
            exec {
                commandLine "Powershell", "-Command", "Stop-Process", "-Id", pid, "-PassThru"
            }
        } else {
            exec {
             commandLine "kill", "-9", pid
            }
        }

        new ProcessBuilder("docker", "stop", dbContainerName).start()

    }
}



def createCsdeRpcInterface() {
    return new CsdeRpcInterface(cordaClusterURL, cordaRpcUser, cordaRpcPasswd, devEnvWorkspace)
}

public class CsdeException extends Exception {

}

public class CsdeRpcInterface {
    private String baseURL = "https://localhost:8888";
    //private String baseURL = "http://localhost:2008";
    private String rpcUser = "admin";
    private String rpcPasswd = "admin";
    private String workspaceDir = "workspace";
    static private int retryWaitMs = 1000;
    static PrintStream out = System.out;
    private String CPIUploadStatusFName = "CPIFileStatus.json";
    private String X500ConfigFile = "config/dev-net.json";

    public CsdeRpcInterface() {
        // CsdeExtension ext = extensions.getByName("csde") as CsdeExtension;
    }

    public CsdeRpcInterface (String inBaseUrl, String inRpcUser, String inRpcPasswd, String inWorkspaceDir) {
        baseURL = inBaseUrl;
        rpcUser = inRpcUser;
        rpcPasswd = inRpcPasswd;
        workspaceDir = inWorkspaceDir;
        CPIUploadStatusFName = workspaceDir +"/"+ CPIUploadStatusFName;
    }

    static private void rpcWait(int millis) {
        try {
            sleep(retryWaitMs);
        }
        catch(InterruptedException e) {
            throw new UnsupportedOperationException("Interrupts not supported.", e);
        }
    }

    public LinkedList<String> getConfigX500Ids() throws IOException {
        LinkedList<String> x500Ids = new LinkedList<String>();
        com.fasterxml.jackson.databind.ObjectMapper mapper = new com.fasterxml.jackson.databind.ObjectMapper();

        FileInputStream in = new FileInputStream(X500ConfigFile);
        com.fasterxml.jackson.databind.JsonNode jsonNode = mapper.readTree(in);
        for( com.fasterxml.jackson.databind.JsonNode identity:  jsonNode.get("identities")) {
            String idAsString = identity.toString();
            x500Ids.add(idAsString.substring(1,idAsString.length()-1));
        }
        return x500Ids;
    }

    static public String getLastCPIUploadChkSum(@NotNull String CPIUploadStatusFName) throws IOException, NullPointerException {

        com.fasterxml.jackson.databind.ObjectMapper mapper = new com.fasterxml.jackson.databind.ObjectMapper();
        FileInputStream in = new FileInputStream(CPIUploadStatusFName);
        com.fasterxml.jackson.databind.JsonNode jsonNode = mapper.readTree(in);
        // out.println("CPI File status data:\n"+ jsonNode.toPrettyString());

        String checksum = jsonNode.get("cpiFileChecksum").toString();
        if(checksum == null || checksum.equals("null")) {
            throw NullPointerException("Missing cpiFileChecksum in file " + CPIUploadStatusFName+ " with contents:" + jsonNode.toString());
        }
        return checksum;
    }


    public void reportError(@NotNull kong.unirest.HttpResponse<kong.unirest.JsonNode> response){
        out.println("*** *** ***");
        out.println("Should throw execption:");
        out.println("Status="+ response.getStatus());
        out.println("*** Headers ***\n"+ response.getHeaders());
        out.println("*** Body ***\n"+ response.getBody());
        out.println("*** *** ***");
    }

    //
    public void downloadFile(String url, String targetPath) {
        File result = Unirest.get(url)
                .asFile(targetPath)
                .getBody();
    }

    public kong.unirest.HttpResponse<kong.unirest.JsonNode> getVNodeInfo() {
        Unirest.config().verifySsl(false);
        return Unirest.get(baseURL + "/api/v1/virtualnode/")
                .basicAuth(rpcUser, rpcPasswd)
                .asJson();
    }

    public void listVNodesVerbose() {
        kong.unirest.HttpResponse<kong.unirest.JsonNode> vnodeResponse = getVNodeInfo();
        out.println("VNodes:\n" + vnodeResponse.getBody().toPrettyString());
    }

    // X500Name, cpiname, shorthash,
    public void listVNodes() {
        kong.unirest.HttpResponse<kong.unirest.JsonNode> vnodeResponse = getVNodeInfo();

        kong.unirest.json.JSONArray virtualNodesJson = vnodeResponse.getBody().getObject().get("virtualNodes");
        out.println("X500 Name\tHolding identity short hash");
        for(Object o: virtualNodesJson){
            if(o instanceof kong.unirest.json.JSONObject) {
                kong.unirest.json.JSONObject idObj = ((kong.unirest.json.JSONObject) o).getJSONObject('holdingIdentity');
                out.print("\"" + idObj.get('x500Name') + "\"");
                out.println("\t\"" + idObj.get('shortHash') + "\"");
            }
        }
    }

    public kong.unirest.HttpResponse<kong.unirest.JsonNode> getCpiInfo() {
        Unirest.config().verifySsl(false);
        return Unirest.get(baseURL + "/api/v1/cpi/")
                .basicAuth(rpcUser, rpcPasswd)
                .asJson();

    }

    public void listCPIs() {
        kong.unirest.HttpResponse<kong.unirest.JsonNode> cpiResponse  = getCpiInfo();
        kong.unirest.json.JSONArray jArray = cpiResponse.getBody().getObject().get("cpis");

        for(Object o: jArray){
            if(o instanceof kong.unirest.json.JSONObject) {
                kong.unirest.json.JSONObject idObj = ((kong.unirest.json.JSONObject) o).getJSONObject('id');
                out.print("cpiName=" + idObj.get('cpiName'));
                out.println(", cpiVersion=" + idObj.get('cpiVersion'));
            }
        }
    }

    public void uploadCertificate(String certAlias, String certFName) {
        Unirest.config().verifySsl(false);
        kong.unirest.HttpResponse<kong.unirest.JsonNode> uploadResponse = Unirest.put(baseURL + "/api/v1/certificates/codesigner/")
                .field("alias", certAlias)
                .field("certificate", new File(certFName))
                .basicAuth(rpcUser, rpcPasswd)
                .asJson();
        println("Certificate/key upload, alias "+certAlias+" certificate/key file "+certFName);
        println(uploadResponse.getBody().toPrettyString());
    }

   public void forceuploadCPI(String cpiFName) throws FileNotFoundException {
        Unirest.config().verifySsl(false);
        kong.unirest.HttpResponse<kong.unirest.JsonNode> jsonResponse = Unirest.post(baseURL + "/api/v1/maintenance/virtualnode/forcecpiupload/")
                .field("upload", new File(cpiFName))
                .basicAuth(rpcUser, rpcPasswd)
                .asJson();

        if(jsonResponse.getStatus() == 200) {
            String id = (String) jsonResponse.getBody().getObject().get("id");
            out.println("get id:\n" +id);
            kong.unirest.HttpResponse<kong.unirest.JsonNode> statusResponse = uploadStatus(id);

            if (statusResponse.getStatus() == 200) {
                PrintStream cpiUploadStatus = new PrintStream(new FileOutputStream(CPIUploadStatusFName));
                cpiUploadStatus.print(statusResponse.getBody());
                out.println("Caching CPI file upload status:\n" + statusResponse.getBody());
            } else {
                reportError(statusResponse);
            }
        }
        else {
            reportError(jsonResponse);
        }
    }

    private boolean uploadStatusRetry(kong.unirest.HttpResponse<kong.unirest.JsonNode> response) {
        int status = response.getStatus();
        kong.unirest.JsonNode body = response.getBody()
        // Do not retry on success
        if(status == 200) {
            // Keep retrying until we get "OK" may move through "Validateing upload", "Persisting CPI"
            return !(body.getObject().get("status").equals("OK"))
        }
        else if (status == 400){
            JSONObject details = response.getBody().getObject().getJSONObject("details");
            if( details != null ){
                String code = (String) details.getString('code');
                return !code.equals("BAD_REQUEST");
            }
            else {
                // 400 otherwise means some transient problem
                return true;
            }
        }
        else if (status == 409)
        {
            return false;
        }
        return false;
    }

    public kong.unirest.HttpResponse<kong.unirest.JsonNode> uploadStatus(String requestId) {
        kong.unirest.HttpResponse<kong.unirest.JsonNode> statusResponse = null;
        int tries=0;
        do {
            rpcWait(1000);
            statusResponse = Unirest
                    .get(baseURL + "/api/v1/cpi/status/" + requestId + "/")
                    .basicAuth(rpcUser, rpcPasswd)
                    .asJson();
            tries++;
            out.println("Upload status="+statusResponse.getStatus()+", status query response:\n"+statusResponse.getBody().toPrettyString());
        }
        while(uploadStatusRetry(statusResponse));

        return statusResponse;
    }

    public void deployCPI(String cpiFName, String cpiName, String cpiVersion) throws FileNotFoundException {
        Unirest.config().verifySsl(false);

        kong.unirest.HttpResponse<kong.unirest.JsonNode> cpiResponse  = getCpiInfo()
        kong.unirest.json.JSONArray jArray = cpiResponse.getBody().getObject().get("cpis");

        int matches = jArray.toList().stream().filter(o -> {
            if(o instanceof kong.unirest.json.JSONObject){
                kong.unirest.json.JSONObject idObj = ((kong.unirest.json.JSONObject) o).getJSONObject('id');

                return (idObj.get('cpiName').toString().equals(cpiName)
                        && idObj.get('cpiVersion').toString().equals(cpiVersion));
            }
            else {
                return false;
            }
        }).count();
        println("Matching CPIS="+matches);


       if(matches == 0) {
           kong.unirest.HttpResponse<kong.unirest.JsonNode> uploadResponse = Unirest.post(baseURL + "/api/v1/cpi/")
                   .field("upload", new File(cpiFName))
                   .basicAuth(rpcUser, rpcPasswd)
                   .asJson();

           kong.unirest.JsonNode body = uploadResponse.getBody();

           int status = uploadResponse.getStatus();

           out.println("Upload Status:" + status);
           out.println("Pretty print the body\n" + body.toPrettyString());

           // We expect the id field to be a string.
           if (status == 200) {
               String id = (String) body.getObject().get("id");
               out.println("get id:\n" + id);

               kong.unirest.HttpResponse<kong.unirest.JsonNode> statusResponse = uploadStatus(id);
               if (statusResponse.getStatus() == 200) {
                   PrintStream cpiUploadStatus = new PrintStream(new FileOutputStream(CPIUploadStatusFName));
                   cpiUploadStatus.print(statusResponse.getBody());
                   out.println("Caching CPI file upload status:\n" + statusResponse.getBody());
               } else {
                   reportError(statusResponse);
               }
           } else {
               reportError(uploadResponse);
           }
       }
        else {
           out.println("CPI already uploaded doing a 'force' upload.");
           forceuploadCPI(cpiFName);
       }
    }

    public void createAndRegVNodes() throws IOException{
        Unirest.config().verifySsl(false);
        String cpiCheckSum = getLastCPIUploadChkSum( CPIUploadStatusFName );

        LinkedList<String> x500Ids = getConfigX500Ids();
        LinkedList<String> OKHoldingShortIds = new LinkedList<String>();

        // For each identity check that it already exists.
        Set<MemberX500Name> existingX500 = new HashSet<>();
        kong.unirest.HttpResponse<kong.unirest.JsonNode> vnodeListResponse = getVNodeInfo();

        kong.unirest.json.JSONArray virtualNodesJson = vnodeListResponse.getBody().getObject().get("virtualNodes");
        for(Object o: virtualNodesJson){
            if(o instanceof kong.unirest.json.JSONObject) {
                kong.unirest.json.JSONObject idObj = ((kong.unirest.json.JSONObject) o).getJSONObject('holdingIdentity');
                String x500id = idObj.get('x500Name')
                existingX500.add(MemberX500Name.parse( x500id) );
            }
        }

        // Create the VNodes
        for(String x500id: x500Ids) {
            if(!existingX500.contains(MemberX500Name.parse(x500id) )) {
                out.println("Creating VNode for x500id=\"" + x500id + "\" cpi checksum=" + cpiCheckSum);
                kong.unirest.HttpResponse<kong.unirest.JsonNode> jsonNode = Unirest.post(baseURL + "/api/v1/virtualnode")
                        .body("{ \"request\" : { \"cpiFileChecksum\": " + cpiCheckSum + ", \"x500Name\": \"" + x500id + "\" } }")
                        .basicAuth(rpcUser, rpcPasswd)
                        .asJson();
                // Logging.

                // need to check this and report errors.
                // 200 - OK
                // 409 - Vnode already exists
                if (jsonNode.getStatus() != 409) {
                    if (jsonNode.getStatus() != 200) {
                        reportError(jsonNode);
                    } else {
                        JSONObject thing = jsonNode.getBody().getObject().getJSONObject("holdingIdentity");
                        String shortHash = (String) thing.get("shortHash");
                        OKHoldingShortIds.add(shortHash);
                    }
                }
            }
            else {
                out.println("Not creating a vnode for \"" + x500id + "\", vnode already exists.")
            }
        }

        // Register the VNodes
        for(String shortHoldingIdHash: OKHoldingShortIds) {
            kong.unirest.HttpResponse<kong.unirest.JsonNode> vnodeResponse = Unirest.post(baseURL + "/api/v1/membership/" + shortHoldingIdHash)
                    .body("{ \"memberRegistrationRequest\": { \"action\": \"requestJoin\",  \"context\": { \"corda.key.scheme\" : \"CORDA.ECDSA.SECP256R1\" } } }")
                    .basicAuth(rpcUser, rpcPasswd)
                    .asJson();

            out.println("Vnode membership submission:\n" + vnodeResponse.getBody().toPrettyString());
        }

    }

}
