import javax.net.ssl.SSLContext
import javax.net.ssl.TrustManager
import javax.net.ssl.X509TrustManager
import javax.security.auth.x500.X500Principal
import java.net.http.HttpClient
import java.net.http.HttpRequest
import java.net.http.HttpResponse
import java.nio.charset.Charset
import java.security.SecureRandom
import java.util.HashMap
import java.util.regex.Matcher
import java.util.regex.Pattern
import java.lang.ProcessHandle
import java.lang.String

import static org.gradle.api.JavaVersion.VERSION_11

plugins {
    id 'org.jetbrains.kotlin.jvm'

    // Include the cordapp-cpb plugin. This automatically includes the cordapp-cpk plugin as well.
    // These extend existing build environment so that CPB and CPK files can be built.
    // This includes a CorDapp DSL that allows the developer to supply metadata for the CorDapp
    // required by Corda.
    id 'net.corda.plugins.cordapp-cpb'

    // Development Support tools
    // Plugin that provides gradle functions to download files from websites.
    id "de.undercouch.download" version "5.1.0"

    // id 'com.github.hesch.execfork' version '0.1.15'
    id "com.github.psxpaul.execfork" version "0.2.0"

    id 'java'
}

group 'com.r3.hellocorda'
version '1.0-SNAPSHOT'

def javaVersion = VERSION_11

// The CordApp section.
// This is part of the DSL provided by the corda plugins to define metadata for our CorDapp.
// Each component of the CorDapp would get its own CorDapp section in the build.gradle file for the componentâ€™s
// subproject.
// This is required by the corda plugins to build the CorDapp.
cordapp {
    // "targetPlatformVersion" and "minimumPlatformVersion" are intended to specify the preferred
    // and earliest versions of the Corda platform that the CorDapp will run on respectively.
    // Enforced versioning has not implemented yet so we need to pass in a dummy value for now.
    // The platform version will correspond to and be roughly equivalent to the Corda API version.
    targetPlatformVersion platformVersion as Integer
    minimumPlatformVersion platformVersion as Integer

    // The cordapp section contains either a workflow or contract subsection depending on the type of component.
    // Declares the type and metadata of the CPK (this CPB has one CPK).
    workflow {
        name "ModuleNameHere"
        versionId 1
        vendor "VendorNameHere"
    }
}

// Declare the set of Kotlin compiler options we need to build a CorDapp.
tasks.withType(org.jetbrains.kotlin.gradle.tasks.KotlinCompile).configureEach {
    kotlinOptions {
        allWarningsAsErrors = true

        // Specify the version of Kotlin that we are that we will be developing. 
        languageVersion = '1.7'
        // Specify the Kotlin libraries that code is compatible with
        apiVersion = '1.7'
        // Note that we Need to use a version of Kotlin that will be compatible with the Corda API.
        // Currently that is developed in Kotlin 1.7 so picking the same version ensures compatibility with that.

        // Specify the version of Java to target.
        jvmTarget = javaVersion

        // Needed for reflection to work correctly.
        javaParameters = true

        // -Xjvm-default determines how Kotlin supports default methods.
        // JetBrains currently recommends developers use -Xjvm-default=all
        // https://kotlinlang.org/api/latest/jvm/stdlib/kotlin.jvm/-jvm-default/
        freeCompilerArgs += [
                "-Xjvm-default=all"
        ]
    }
}

repositories {

    // Repository the provides kotlin-stdlib-jdk8-osgi created by R3.
    // Final location to be decided.
    maven {
        url = "$artifactoryContextUrl/corda-dependencies"
    }

    // Repository provides Corda 5 binaries that implement Corda-API.
    // These will be made publicly available.
    // Final location to be decided.
    // Repository subject to change
    maven {
        url = "$artifactoryContextUrl/corda-os-maven"
        credentials {
            username = findProperty('cordaArtifactoryUsername') ?: System.getenv('CORDA_ARTIFACTORY_USERNAME')
            password = findProperty('cordaArtifactoryPassword') ?: System.getenv('CORDA_ARTIFACTORY_PASSWORD')
        }
    }

    // Provides the combined-worker Jars
    // These will be made publicly available.
    // Final location to be decided.
    maven {
        url = "$artifactoryContextUrl/corda-ent-maven-unstable-local"
        credentials {
            username = findProperty('cordaArtifactoryUsername') ?: System.getenv('CORDA_ARTIFACTORY_USERNAME')
            password = findProperty('cordaArtifactoryPassword') ?: System.getenv('CORDA_ARTIFACTORY_PASSWORD')
        }
    }

    maven {
        url = "$artifactoryContextUrl/engineering-tools-maven-unstable"
        credentials {
            username = findProperty('cordaArtifactoryUsername') ?: System.getenv('CORDA_ARTIFACTORY_USERNAME')
            password = findProperty('cordaArtifactoryPassword') ?: System.getenv('CORDA_ARTIFACTORY_PASSWORD')
        }
    }

    // Provides all other dependencies
    mavenCentral()

}

// Declare dependencies for the modules we will use.
// A cordaProvided declaration is required for anything that we use that the Corda API provides.
// This is required to allow us to build CorDapp modules as OSGi bundles that CPI and CPB files are built on.
dependencies {
    // We need a version of kotlin-stdlib-jdk8 built as an OSGi bundle, this is "kotlin-stdlib-jdk8-osgi".
    // R3 builds kotlin-stdlib-jdk8-osgi from Kotlin's kotlin-stdlib-jdk8.
    // NB:
    //   Kotlin's kotlin-osgi-bundle does not provide all of the Kotlin API that is required,
    //   There is no kotlin-stdlib-jdk11, but one is not needed even though we are targetting Java 11.
    cordaProvided 'net.corda.kotlin:kotlin-stdlib-jdk8-osgi'

    // Declare a "platform" so that we use the correct set of dependency versions for the version of the
    // Corda API specified.
    cordaProvided platform("net.corda:corda-api:$cordaApiVersion")

    // If using transistive dependencies this will provide most of Corda-API: 
    // cordaProvided 'net.corda:corda-application'

    // Alternatively we can explicitly specify all our Corda-API dependencies:
    cordaProvided 'net.corda:corda-base'
    cordaProvided 'net.corda:corda-application'
    cordaProvided 'net.corda:corda-crypto'
    cordaProvided 'net.corda:corda-membership'
    cordaProvided 'net.corda:corda-persistence'
    cordaProvided 'net.corda:corda-serialization'


    // Not yet fully implemented:
    // cordaProvided 'net.corda:corda-ledger'

    // The CorDapp uses the slf4j logging framework. Corda-API provides this so we need a 'cordaProvided' declaration.
    cordaProvided 'org.slf4j:slf4j-api'

    // Dependencies Required By Test Tooling
    //testImplementation "net.corda:library:$testUtilsVersion"
    testImplementation "net.corda:cordapp-test-utils:$testUtilsVersion"

    // 3rd party libraries
    // Required
    testImplementation "org.junit.jupiter:junit-jupiter:$junitVersion"
    testRuntimeOnly "org.junit.jupiter:junit-jupiter-engine:$junitVersion"

    // Optional but used by exmaple tests.
    testImplementation "org.mockito:mockito-core:$mockitoVersion"
    testImplementation "org.mockito.kotlin:mockito-kotlin:$mockitoKotlinVersion"
    testImplementation "org.hamcrest:hamcrest-library:$hamcrestVersion"

}


test {
    useJUnitPlatform()
}

// Support tooling
configurations {
    combinedWorker{
        canBeConsumed = false
        canBeResolved= true
    }

    cordaCli{
        canBeConsumed = false
        canBeResolved= true
    }

    cordaCliMgmPlugin {
        canBeConsumed = false
        canBeResolved = true
    }

    cordaCliPackagePlugin {
        canBeConsumed = false
        canBeResolved = true
    }

    myCordaCpb {
        canBeConsumed = false
    }

    // TODO reconsider this
    all {
        resolutionStrategy {
            // FORCE Gradle to use latest dynamic versions.
            cacheDynamicVersionsFor 0, 'seconds'
        }
    }

}

// Dependencies for supporting tools
dependencies {
    combinedWorker "net.corda:corda-combined-worker:$combinedWorkerVersion"
    cordaCli "net.corda.cli.host:corda-cli:$cordaCliVersion"
    cordaCliMgmPlugin "net.corda.cli.deployment:mgm-cli-plugin:$cordaCluPluginsVersion"
    cordaCliPackagePlugin "net.corda.cli.deployment:package-cli-plugin:$cordaCluPluginsVersion"
}


def cordaBinDir="${System.getProperty('user.home')}/.corda/corda5"


tasks.register('listCli'){
    print("Corda-Cli configuration:")
    configurations.cordaCli.each { println(it) }
    print("MGM configuration:")
    configurations.cordaCliMgmPlugin.each { println(it) }
    print("Package configuration:")
    configurations.cordaCliPackagePlugin.each { println(it) }

}

//def combiWorkerJar = "${System.getProperty('user.home')}/.corda/corda5/corda-combined-worker-5.0.0.0-beta-1659630320700.jar"
//def combiWorkerJar = "$cordaBinDir/corda-combined-worker-5.0.0.0-beta-1659630320700.jar"

//def cordaCliStorageDir = "$cordaBinDir/corda-cli-storage"
// def cordaCliStorageDir = "$cordaBinDir/test-corda-cli-storage"
//def cordaCliDir = "$cordaBinDir/corda-cli-plugin-host"
def cordaCliDir = "$cordaBinDir/corda-cli"
//def cordaCliDir = "$cordaBinDir/test"

// def CORDA_CLI_JAR = "corda-cli-0.0.1-SNAPSHOT.jar"
//def CORDA_CLI_JAR = "corda-cli-0.0.1-beta-1659584654941.jar"
//def CORDA_CLI_JAR_DIR = "${cordaCliStorageDir}/app/build/libs"
//def CORDA_CLI_PLUGINS_DIR = "${cordaCliDir}/build/plugins"
//def CORDA_CLI_PLUGINS_DIR = "${cordaCliSDir}/plugins"
def CORDA_CLI_JAR_DIR = "${cordaCliDir}"
def CORDA_CLI_PLUGINS_DIR = "${cordaCliDir}/plugins"

tasks.register('projInit') {
    doLast {
        mkdir devEnvWorkspace
    }
}

tasks.register("getCordaCli") {
    //dependsOn('getCordaCliMgmPlugin', 'getCordaCliPackagePlugin')
    doLast {
        delete {
            delete cordaCliDir
        }
        copy {
            from configurations.cordaCli
            into "$cordaCliDir"
        }
        copy {
            from configurations.cordaCliPackagePlugin
            into "$cordaCliDir/plugins"
        }
        copy {
            from configurations.cordaCliMgmPlugin
            into "$cordaCliDir/plugins"
        }
    }
}

tasks.register("createGroupPolicy") {
    //classpath = files("$cordaCliStorageDir/$CORDA_CLI_JAR")
    //classpath = files("$CORDA_CLI_JAR_DIR/corda-cli-0.0.1-SNAPSHOT.jar"
    dependsOn('projInit')
    doLast {
        javaexec {
            classpath = configurations.cordaCli
            jvmArgs = ["-Dpf4j.pluginsDir=$CORDA_CLI_PLUGINS_DIR"]
            standardOutput = new FileOutputStream("${devEnvWorkspace}/GroupPolicy.json")
            LinkedList<String> myArgs = new LinkedList<String>()
            myArgs.add("mgm")
            myArgs.add("groupPolicy")
            def jsonFile = file("$rootDir/config/dev-net.json")
            def slurper = new groovy.json.JsonSlurper()
            def parsedJson = slurper.parseText(jsonFile.text)
            parsedJson.identities.forEach {
                myArgs.add("--name")
                myArgs.add(it)
            }

            myArgs.add("--endpoint-protocol=1")
            myArgs.add("--endpoint=http://localhost:1080")
            args myArgs
        }
    }
}

tasks.register('printCPB' ) {
    dependsOn('cpb')
    println("myCordaCpb=${configurations.myCordaCpb.files()}")
    println("cpb.outputs.files()=${cpb.outputs.files()}")
    println("assemble.outputs.files()=${assemble.outputs.files()}")

    // println(cpb.get().outputFile)
    //File cpbFile = file('build/libs/*.cpb')
    // inputs.files(myCordaCpb).withPropertyName('cpb').withPathSensitivity(PathSensitivity.RELATIVE)
    //println("${configurations.myCordaCpb.singleFile.absolutePath}")
    println("$buildDir/libs/")

    //println("cbp={$cpb.toString()}")
    //println("Cpb file=${cpbFile.absolutePath}")
}

tasks.register("getMiniCorda", Copy) {
    from configurations.combinedWorker
    into cordaBinDir
}

/*
tasks.register('addTsaCertToKeystore') {
    dependsOn ('createKeystore')
    doLast {
        println('addTsaCertToKeystore running')
        exec {
            commandLine "keytool", "-importcert",
                    "-alias", "freetsa",
                    "-keystore", "signingkeys.pfx",
                    "-storepass", "keystore password",
                    "-file", "cacert.pem",
                    "-noprompt"
        }
    }

}

tasks.register('deleteOldSigningKeys'){
        doLast {
            println('deleteOldSigningKeys running')
            delete {
               "${rootDir}/signingkeys.pfx"
            }
            exec {
                commandLine 'ls', '-l', rootDir
            }
        }
}

tasks.register('createKeystore') {
    dependsOn('deleteOldSigningKeys','downloadFreeTsaCert')
    println('createKeystore')
    doLast {
        println('createKeystore running')
        exec {
            commandLine "keytool", "-genkey",
                    "-alias", "my-signing-key",
                    "-keystore", "signingkeys.pfx",
                    "-storepass", "keystore password",
                    "-dname", "cn=CPI Example - My Signing Key, o=CorpOrgCorp, c=GB",
                    "-keyalg", "RSA",
                    "-storetype", "pkcs12",
                    "-validity", "4000"
        }
    }
}

 */

tasks.register('downloadFreeTsaCert', Download) {
    dependsOn('projInit')
    src 'https://freetsa.org/files/cacert.pem'
    dest devEnvWorkspace
    overwrite false
}

tasks.register('createKeystore') {
    dependsOn('downloadFreeTsaCert')
    println('createKeystore')
    println("devEnvWorkspace=$devEnvWorkspace")
    doLast {
        delete {
            delete "$devEnvWorkspace/signingkeys.pfx"
        }
        exec {
            commandLine "keytool", "-genkey",
                    "-alias", "my-signing-key",
                    "-keystore", "$devEnvWorkspace/signingkeys.pfx",
                    "-storepass", "keystore password",
                    "-dname", "cn=CPI Example - My Signing Key, o=CorpOrgCorp, c=GB",
                    "-keyalg", "RSA",
                    "-storetype", "pkcs12",
                    "-validity", "4000"
        }
        exec {
            commandLine "keytool", "-importcert",
                    "-alias", "freetsa",
                    "-keystore", "$devEnvWorkspace/signingkeys.pfx",
                    "-storepass", "keystore password",
                    "-file", "${devEnvWorkspace}/cacert.pem",
                    "-noprompt"
        }
    }
}

tasks.register('buildCPI') {
    dependsOn('cpb', 'createGroupPolicy', 'createKeystore')

    doLast{
        def cpiFile= "${buildDir}/${project.archivesBaseName}-${project.version}.cpi"
        delete { delete cpiFile }
        File srcDir
        srcDir = file('build/libs')

        // Create a file collection using a closure
        def collection = layout.files { srcDir.listFiles() }
        //def cpbs = collection.filter { it.getName().endsWith(".cpb") }.each { println it }
        def cpbs = collection.filter { it.getName().endsWith(".cpb") }
        javaexec {
            classpath = configurations.cordaCli
            jvmArgs = ["-Dpf4j.pluginsDir=$CORDA_CLI_PLUGINS_DIR"]
            args 'package', 'create',
                    '--cpb', cpbs.singleFile.absolutePath,
                    '--group-policy', "${devEnvWorkspace}/GroupPolicy.json",
                    '--keystore', "${devEnvWorkspace}/signingkeys.pfx",
                    '--storepass', 'keystore password',
                    '--key', 'my-signing-key',
                    '--tsa', 'https://freetsa.org/tsr',
                    '--file', cpiFile
        }
    }
}

tasks.register('parseJson') {
     doLast {
         def jsonFile = file("$rootDir/config/dev-net.json")
         def slurper = new groovy.json.JsonSlurper()
         def parsedJson = slurper.parseText(jsonFile.text)
         println("${parsedJson.identities}")
     }
}

tasks.register("deployCPI") {
    dependsOn('buildCPI')
    doLast {
        def retryLimit = 10
        def retryWaitInMs = 3000
        def retries=0
        def cpi = "${buildDir}/${project.archivesBaseName}-${project.version}.cpi"
        exec {
            standardOutput = new FileOutputStream("${devEnvWorkspace}/CPIupload.json")
            commandLine "curl", "--insecure", "-u", "admin:admin", "-s",
                    "-F", "upload=@$cpi",
                    "https://localhost:8888/api/v1/cpi/"
        }
        def jsonFile = file("${devEnvWorkspace}/CPIupload.json")
        // println("upload attempt output:${jsonFile.text}")
        def slurper = new groovy.json.JsonSlurper()
        def parsedJson = slurper.parseText(jsonFile.text)
        // println("Request ID=${parsedJson.id}")


        // Loop if status != 400 and we don't have have a CPI Checksum
        def requestId = parsedJson.id
        // println(requestId)
        Object parsedJsonCPI = null
        do {
            Thread::sleep(retryWaitInMs)
            exec {
                standardOutput = new FileOutputStream("${devEnvWorkspace}/CPIFileStatus.json")
                commandLine "curl", "--insecure", "-u", "admin:admin", "-s",
                        "https://localhost:8888/api/v1/cpi/status/${requestId}"
            }
            def jsonFileCPI = file("${devEnvWorkspace}/CPIFileStatus.json")
            // println("initial upload status:${jsonFileCPI.text}")
            parsedJsonCPI = new groovy.json.JsonSlurper().parseText(jsonFileCPI.text)
            // println("status=$parsedJsonCPI.status")
        } while(parsedJsonCPI != null && parsedJsonCPI.status instanceof String && parsedJsonCPI.status != "OK")
        // println("status=$parsedJsonCPI.status")
        if (!parsedJsonCPI.status.equals("OK")) {
            // println("CPI Deployment failed:$parsedJsonCPI.details.errorMessage")

            // Attempt forceCPIupload
            exec {
                standardOutput = new FileOutputStream("${devEnvWorkspace}/CPIupload.json")
                commandLine "curl", "--insecure", "-u", "admin:admin", "-s",
                        "-F", "upload=@$cpi",
                        "https://localhost:8888/api/v1/maintenance/virtualnode/forcecpiupload/"
            }
            def jsonFileForce = file("${devEnvWorkspace}/CPIupload.json")
            def slurperForce = new groovy.json.JsonSlurper()
            // println("forcecpiload output=${jsonFileForce.text}")
            def parsedJsonForce = slurper.parseText(jsonFileForce.text)
            // println("Request ID=${parsedJsonForce.id}")


            // Loop if status != 400 and we don't have have a CPI Checksum
            def jsonFileA = file("${devEnvWorkspace}/CPIupload.json")
            requestId = (new groovy.json.JsonSlurper().parseText(jsonFileA.text)).id
            // println(requestId)
            do {

                Thread::sleep(3000)
                exec {
                    standardOutput = new FileOutputStream("${devEnvWorkspace}/CPIFileStatus.json")
                    commandLine "curl", "--insecure", "-u", "admin:admin", "-s",
                            "https://localhost:8888/api/v1/cpi/status/${requestId}"
                }
                def jsonFileForceStatus = file("${devEnvWorkspace}/CPIFileStatus.json")
                parsedJson = new groovy.json.JsonSlurper().parseText(jsonFileForceStatus.text)

               //  println("status=$parsedJson.status")
            } while (parsedJson != null && parsedJson.status instanceof String && parsedJson.status != "OK")

            if (!parsedJson.status.equals("OK")) {
                println("CPI Deployment failed:$parsedJson.details.errorMessage")
                println(parsedJson)
                throw new GradleException("CPI Deployment failed.\n$parsedJson.details.errorMessage")
            } else {
                //println("CPI checksum=${parsedJson.cpiFileChecksum}")
            }

        } else {
            //println("CPI checksum=${parsedJsonCPI.cpiFileChecksum}")
        }
    }
}


tasks.register("uploadCPI") {
    dependsOn('projInit')
    doLast {
        def cpi = "${buildDir}/${project.archivesBaseName}-${project.version}.cpi"
        println("cpi=$cpi")
        exec {
            standardOutput = new FileOutputStream("${devEnvWorkspace}/CPIupload.json")
            commandLine "curl", "--insecure", "-u", "admin:admin", "-s",
                    "-F", "upload=@$cpi",
                    "https://localhost:8888/api/v1/cpi/"
        }
        def jsonFile = file("${devEnvWorkspace}/CPIupload.json")
        def slurper = new groovy.json.JsonSlurper()
        def parsedJson = slurper.parseText(jsonFile.text)
        println("Request ID=${parsedJson.id}")
    }
}

tasks.register("forceUploadCPI") {
    dependsOn('projInit')
    doLast {
        def cpi = "${buildDir}/${project.archivesBaseName}-${project.version}.cpi"
        standardOutput = new FileOutputStream("${devEnvWorkspace}/CPIupload.json")
        exec {
            commandLine "curl", "--insecure", "-u", "admin:admin",  "-s",
                    "-F", "upload=@$cpi",
                    "https://localhost:8888/api/v1/maintenance/virtualnode/forcecpiupload/"
        }
        def jsonFile = file("${devEnvWorkspace}/CPIupload.json")
        def parsedJson = new groovy.json.JsonSlurper().parseText(jsonFile.text)
        println("${parsedJson.id}")
    }
}



tasks.register("uploadCPIStatus") {
    // dependsOn ('uploadCPI')
    dependsOn('projInit')
    doLast {
        def jsonFileA = file("${devEnvWorkspace}/CPIupload.json")
        def requestId = (new groovy.json.JsonSlurper().parseText(jsonFileA.text)).id
        // println(requestId)
        exec {
            standardOutput = new FileOutputStream("${devEnvWorkspace}/CPIFileStatus.json")
            commandLine "curl", "--insecure", "-u", "admin:admin",  "-s",
                    "https://localhost:8888/api/v1/cpi/status/${requestId}"
        }
        def jsonFile = file("${devEnvWorkspace}/CPIFileStatus.json")
        def parsedJson = new groovy.json.JsonSlurper().parseText(jsonFile.text)

        // println("status=$parsedJson.status")
        if (!parsedJson.status.equals("OK")) {
            println("CPI Deployment failed:$parsedJson.details.errorMessage")
            println(parsedJson)
            throw new GradleException("CPI Deployment failed.\n$parsedJson.details.errorMessage")
        } else {
            println("CPI checksum=${parsedJson.cpiFileChecksum}")
        }
    }
}

class VNodeInfo {
    public VNodeInfo(String shash, String cpi) {
        ShortHash=shash;
        CPIName=cpi;
    }
    public String ShortHash;
    public String CPIName;
}

tasks.register("createVNodes") {
    dependsOn('deployCPI')
    doLast {
        def jsonFile = file("$rootDir/config/dev-net.json")
        def slurper = new groovy.json.JsonSlurper()
        def parsedJson = slurper.parseText(jsonFile.text)
        def CpiFileStatusFile = file("${devEnvWorkspace}/CPIFileStatus.json")
        def cpiChkSum = (new groovy.json.JsonSlurper().parseText(CpiFileStatusFile.text)).cpiFileChecksum
        // println("ParsedJson=${parsedJson.identities}")
        def namesToShortHashes = new HashMap<String,String>()
        HashMap<String, VNodeInfo> namesToVNodeInfo = new HashMap<String, VNodeInfo>()

        delete {
            delete "${devEnvWorkspace}/vnodes.json"
        }
        exec {
            standardOutput = new FileOutputStream("${devEnvWorkspace}/existingvnodes.json")
            commandLine "curl", "--insecure", "-u", "admin:admin", "-s",
                    "https://localhost:8888/api/v1/virtualnode"
        }

        def existingVNodes = new HashSet<X500Principal>()
        def rawExistingVNodeData=file("${devEnvWorkspace}/existingvnodes.json")
        def existingVNodeData = new groovy.json.JsonSlurper().parseText(rawExistingVNodeData.text)
        /*
        existingVNodeData.virtualNodes.forEach {
            println("Existing: ${it.holdingIdentity.x500Name}")
        }

         */
        existingVNodeData.virtualNodes.forEach {
            existingVNodes.add(new X500Principal(it.holdingIdentity.x500Name))
        }

        /*
        println("Existing as X500Principals:")
        existingVNodes.forEach {
            println("X500Principal: $it")
        }

        // Doesn't not work
        println("Check for existence with string search:")
        existingVNodeData.virtualNodes.forEach {
            String myX500Name = it.holdingIdentity.x500Name
            println("$myX500Name: does it match ${existingVNodes.contains(myX500Name)}")
        }

        // Need to create X500... thing to work
        println("Check for existence with X500Principal search:")
        existingVNodeData.virtualNodes.forEach {
            String myX500Name = it.holdingIdentity.x500Name
            println("${myX500Name}: does it match ${existingVNodes.contains(new X500Principal(myX500Name))}")
        }
        parsedJson.identities.forEach {
            X500Principal x500 = new X500Principal(it)
            println("$it, as X500 getname ${x500.getName()}, as string ${x500}")
        }
        */

        Thread::sleep(6000)
        def vnodeInfoOutput = new PrintStream(new FileOutputStream("${devEnvWorkspace}/vnodeinfo.csv"))
        parsedJson.identities.forEach {
            def X500 = it
            if (!existingVNodes.contains(new X500Principal(X500))) {
                //println("Create VNode for $X500 with CPI(with check sum) $cpiChkSum")
                exec {
                    standardOutput = new FileOutputStream("${devEnvWorkspace}/vnodetemp.json")
                    commandLine "curl", "--insecure", "-u", "admin:admin", "-s",
                            "-d", "{ \"request\" : { \"cpiFileChecksum\": \"$cpiChkSum\", \"x500Name\": \"$X500\"  } }",
                            "https://localhost:8888/api/v1/virtualnode"
                }
                def outputData = file("${devEnvWorkspace}/vnodetemp.json")
                //println("Data=${outputData.text}")
                // TODO: Can do error checking with this
                def jsonOut = new groovy.json.JsonSlurper().parseText(outputData.text)

                if(jsonOut.holdingIdentity != null) {
                    def idShortHash = jsonOut.holdingIdentity.shortHash
                    namesToShortHashes.put(X500, idShortHash)
                    namesToVNodeInfo.put(X500, new VNodeInfo(idShortHash, cpiChkSum))
                    //println("\"$X500\", \"$idShortHash\"")
                    //println(".shortHash=$idShortHash")
                }

            } else {
                //println("Already created $X500")
            }
        }

        // Debugging
        /*
        exec {
            commandLine "curl", "--insecure", "-u", "admin:admin", "-s",
                    "https://localhost:8888/api/v1/virtualnode"
        }
        */
        /*
        def vnodeInfoOutput = new PrintStream(new FileOutputStream("${devEnvWorkspace}/vnodeinfo.json"))
        //createVNodeFile(vnodeInfoOutput, namesToVNodeInfo)
        vnodeInfoOutput.println('{')
        vnodeInfoOutput.println("  \"vnodes\": [")
        boolean first=true
        for(String X500: namesToVNodeInfo) {
            VNodeInfo info = namesToVNodeInfo.get(X500)
            vnodeInfoOutput.print("    { \"X500\": \"" + X500 + "\", \"shortHash\": \"" + info.ShortHash + "\", \"CPI\": \"" + info.CPIName +"\" }" )
            if(!first) { print(',')}
            vnodeInfoOutput.print('\n')
        }
        vnodeInfoOutput.println('  ]\n}')
        */

        /*
        // Code the check for registration
        parsedJson.identities.forEach {
            def X500 = it
            if (!existingVNodes.contains(new X500Principal(X500))) {
                if(namesToShortHashes.get(X500)!= null) {
                    println("Register $X500 with shorthash ${namesToShortHashes.get(X500)}")
                    exec {
                        commandLine "curl", "--insecure", "-u", "admin:admin", "-s",
                                "-d", '{ "memberRegistrationRequest": { "action": "requestJoin",  "context": { "corda.key.scheme" : "CORDA.ECDSA.SECP256R1" } } }',
                                "https://localhost:8888/api/v1/membership/${namesToShortHashes.get(X500)}"
                    }
                    print('\n')
                }
            }
        }

         */
   }
}

tasks.register('regAllVNodes') {
    // Code the check for registration
    dependsOn('createVNodes')
    doLast {
        exec {
            standardOutput = new FileOutputStream("${devEnvWorkspace}/existingvnodes.json")
            commandLine "curl", "--insecure", "-u", "admin:admin", "-s",
                    "https://localhost:8888/api/v1/virtualnode"
        }

        def existingVNodes = new HashSet<X500Principal>()
        def rawExistingVNodeData = file("${devEnvWorkspace}/existingvnodes.json")
        def existingVNodeData = new groovy.json.JsonSlurper().parseText(rawExistingVNodeData.text)

        existingVNodeData.virtualNodes.forEach {
            def X500 = it.holdingIdentity.x500Name
            def shortHash = it.holdingIdentity.shortHash
            println("Register $X500 with shorthash ${shortHash}")
            exec {
                commandLine "curl", "--insecure", "-u", "admin:admin", "-s",
                        "-d", '{ "memberRegistrationRequest": { "action": "requestJoin",  "context": { "corda.key.scheme" : "CORDA.ECDSA.SECP256R1" } } }',
                        "https://localhost:8888/api/v1/membership/${shortHash}"
            }
            print('\n')
        }
    }
}

tasks.register('listVNodes') {
    doLast {
        exec {
            standardOutput = new FileOutputStream("${devEnvWorkspace}/tempy.json")
            commandLine "curl", "--insecure", "-u", "admin:admin", "-s",
                    "https://localhost:8888/api/v1/virtualnode"
        }

        def existingVNodes = new HashSet<X500Principal>()
        def rawExistingVNodeData = file("${devEnvWorkspace}/tempy.json")
        def existingVNodeData = new groovy.json.JsonSlurper().parseText(rawExistingVNodeData.text)
        existingVNodeData.virtualNodes.forEach {
            println("${it.holdingIdentity.x500Name}\t${it.holdingIdentity.shortHash}")
        }
    }
}

tasks.register('deployVNodes') {
    dependsOn('regAllVNodes')
}

tasks.register('deployCordapp') {
    dependsOn("deployVNodes")
}

def createVNodeFile(PrintWriter printer, HashMap<String,VNodeInfo> vnodeData) {
    printer.println('{')
    printer.println("  \"vnodes\": [")
    boolean first=true
    for(String X500: vnodeData) {
        VNodeInfo info = vnodeData.get(X500)
        printer.print("    { \"X500\": \"" + X500 + "\", \"shortHash\": \"" + info.ShortHash + "\", \"CPI\": \"" + info.CPIName +"\" }" )
        if(!first) { print(',')}
        printer.print('\n')
    }
    printer.println('  ]\n}')
}


tasks.register("startDB") {
    doLast {
        new ProcessBuilder(
                "docker",
                "run", "-d", "--rm",
                "-p", "5432:5432",
                "--name", dbContainerName,
                "-e", "POSTGRES_DB=cordacluster",
                "-e", "POSTGRES_USER=postgres",
                "-e", "POSTGRES_PASSWORD=password",
                "postgres:latest").start()
    }
}

tasks.register("startCorda") {
    dependsOn('getMiniCorda')
    // def combiWorkerJar = "$cordaBinDir/corda-combined-worker-5.0.0.0-beta-1659630320700.jar"
    doLast {

        /*
        exec {
            commandLine 'mkdir', '-p', "$devEnvWorkspace"
        }

         */

        mkdir devEnvWorkspace

        def combiWorkerJar = configurations.combinedWorker.singleFile

        new ProcessBuilder(
                "docker",
                "run", "-d", "--rm",
                "-p", "5432:5432",
                "--name", dbContainerName,
                "-e", "POSTGRES_DB=cordacluster",
                "-e", "POSTGRES_USER=postgres",
                "-e", "POSTGRES_PASSWORD=password",
                "postgres:latest").start()

        //new ProcessBuilder("$rootDir/tools/postgres-nonpersist-start-detach.sh").start()
        Thread::sleep(10000)
        // def procBuild = new ProcessBuilder("$rootDir/tools/mini-corda-start.sh")


        def javaBinDir = "${System.getProperty("java.home")}/bin"
        def procBuild = new ProcessBuilder("${javaBinDir}/java",
                "-agentlib:jdwp=transport=dt_socket,server=y,suspend=n,address=*:5005",
                "-Dco.paralleluniverse.fibers.verifyInstrumentation=true",
                "-jar",
                "$combiWorkerJar",
                "--instanceId=0",
                "-mbus.busType=DATABASE",
                "-spassphrase=password",
                "-ssalt=salt",
                "-spassphrase=password",
                "-ssalt=salt",
                "-ddatabase.user=user",
                "-ddatabase.pass=password",
                "-ddatabase.jdbc.url=jdbc:postgresql://localhost:5432/cordacluster")


        procBuild.redirectErrorStream(true)
        Process proc = procBuild.start()

        def pidStore = new PrintStream(new FileOutputStream("$devEnvWorkspace/CordaPID.dat"))
        pidStore.print(proc.pid())
        println("Corda Process-id=$proc.pid")
    }
}

tasks.register("stopCorda") {
    doLast {
        def sc = new Scanner(new File("$devEnvWorkspace/CordaPID.dat"))
        def pid = sc.nextLong()
        println("pid to kill=$pid")

        /*
        def pHandle = ProcessHandle.of(pid)
        if(pHandle == null) { println("pHandle == null")}
        else { println("pHandle != null")}

        if(pHandle.ifPresent()) {
            pHandle.get().descendants().each { d ->
                d.destroy()
            }
            def pph = pHandle.get()
            pph.destroy()
        }

         */

        exec {
            commandLine "kill", "-9", pid
        }

        //new ProcessBuilder("$rootDir/tools/postgres-nonpersist-stop.sh").start()
        new ProcessBuilder("docker", "stop", dbContainerName).start()

        // def pHandle = ProcessHandle.of(pid)
        // pHandle.ifPresent(java.lang.ProcessHandle::destroy())
    }
}


// Junk

tasks.register('javabindir') {
    println("${System.getProperty("java.home")}/bin")
}

tasks.register("pickOS") {
    if (System.properties['os.name'].toLowerCase().contains('windows')) {
        println "it's Windows"
    } else {
        println "it's not Windows"
    }
}
tasks.register("clithing") {
    //def collection = configurations.cordaCli
    // def thing = collection.fileCollection().getFiles()
    println("CombinedWorker=${configurations.cordaCli.singleFile}")
    println("CombinedWorker=${configurations.cordaCli.files}")
    def names=[]
    fileTree(cordaCliDir).filter{ }
}

task urldemo {
    doLast {
        Authenticator.setDefault (new Authenticator() {
            protected PasswordAuthentication getPasswordAuthentication() {
                return new PasswordAuthentication ("admin", "admin".toCharArray());
            }
        })
        def body = [user: "dummyUser"]
        def req = new URL('https://localhost:8888/').openConnection()

        req.setRequestMethod("POST")
        req.setRequestProperty("Content-Type", "application/json; charset=UTF-8")
        req.setDoOutput(true)
        req.getOutputStream().write(JsonOutput.toJson(body).getBytes("UTF-8"))
        logger.quiet "Status code: ${req.getResponseCode()}" // HTTP request done on first read
        def resp = new groovy.json.JsonSlurper().parseText(req.getInputStream().getText())
        logger.quiet "Response: ${resp}"
        println("Response: ${resp}")
    }
}

/*
task startDaemon(type: com.github.psxpaul.task.ExecFork) {
    executable = './tools/mini-corda-start.sh'
    // args = <string-array>
    workingDir = "$projectDir"
    standardOutput = new File("$buildDir/daemon.log")
    errorOutput = new File("$buildDir/daemon-error.log")
    // stopAfter = verify
    // waitForPort = 8080
    // waitForOutput = 'has started'
    // environment = ['JAVA_HOME': "$buildDir/java", 'USER_HOME': "$buildDir/userhome"]
}

 */

/*
tasks.register('startMiniCorda', JavaExec) {
   jvmArgs = ['-agentlib:jdwp=transport=dt_socket,server=y,suspend=n,address=*:5005',
              '-Dco.paralleluniverse.fibers.verifyInstrumentation=true']
    //classpath = files(combiWorkerJar)
    classpath = configurations.combinedWorker.singleFile
    args  '--instanceId=0', '-mbus.busType=DATABASE',
          '-spassphrase=password', '-ssalt=salt', '-spassphrase=password', '-ssalt=salt',
            '-ddatabase.user=user', '-ddatabase.pass=password',
            '-ddatabase.jdbc.url=jdbc:postgresql://localhost:5432/cordacluster'
}*/


/*
tasks.register("getCordaCliMgmPlugin", Copy) {
        from configurations.cordaCliMgmPlugin
        into "$cordaCliDir/plugins"
}


tasks.register("getCordaCliPackagePlugin", Copy) {
    from configurations.cordaCliPackagePlugin
    into "$cordaCliDir/plugins"
}

 */
tasks.register('list') {
    //Matcher matcher = Pattern.Compile("corda-combined-worker.*.jar").matcher( it.getName())
    File srcDir

    /*
    srcDir = file('build/libs')
    // Create a file collection using a closure
    def collection = layout.files { srcDir.listFiles() }

    println "Contents of $srcDir.name"
    def cpbs = collection.filter { it.getName().endsWith(".cpb") }.each{ println it }
    println("single file = ${cpbs.singleFile.absolutePath}")
     */

    println("cordaBinDir=$cordaBinDir")
    srcDir = file(cordaBinDir)
    // Create a file collection using a closure
    //def collection = layout.files { srcDir.listFiles() }
    // Configuration, abstracts away location of file.
    // A configuration references files in the repo and will access them from a local cache. It will download those
    // files they are not cached.
    def collection = configurations.combinedWorker

    println("CombinedWorker=${configurations.combinedWorker.singleFile}")
    def bar = collection.each{ println it }
    def foo = collection.filter { it.getName() =~ /"corda-combined-worker.*.jar"/ }.each{ println it }
    // "singleFile" requires that there is only one file in the list.

    // println("single file = ${foo.singleFile.absolutePath}")
}
